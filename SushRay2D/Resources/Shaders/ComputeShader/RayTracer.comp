#version 430 core

#define PI 3.1415926535897932384626433832795

uniform int width;
uniform int height;
uniform int radius;
uniform int rayCount;

uniform vec2 startPos;

layout(RGBA32F) volatile coherent uniform precise image2D lightMapOut;	//texture0

layout(local_size_x = 1, local_size_y = 1) in;

const unsigned int SecSize = rayCount / gl_NumWorkGroups.x;
unsigned int rayCntr = 0;
unsigned int r;

float fallof = float(1.0) / radius;
const float angleDelta = float(2.0 * PI) / rayCount;

vec2 rayPos = {0,0};
vec2 coord;
vec2 xyDelta;
vec2 normPix;	//normalized pixel height(y) and width(x)

vec4 outCol;
vec4 colDelta = vec4(0.1);

void main()
{
	//calculate normalized Pixel height(y) an width(x)
	normPix.x = 1 / width;
	normPix.y = 1 / height;
	for(rayCntr = 0; rayCntr < SecSize; rayCntr++)
	{
		coord = startPos;
		xyDelta.x = sin(angleDelta * ((SecSize * gl_WorkGroupID.x) + rayCntr));
		xyDelta.y = cos(angleDelta * ((SecSize * gl_WorkGroupID.x) + rayCntr));
		for(r = 0; r < radius; r++)
		{
			outCol = imageLoad(lightMapOut, ivec2(floor(coord))) + colDelta;
			//outCol.g = imageLoad(lightMapOut, ivec2(coord)).g;
			//outCol = vec4(0);
			//outCol.r = float(gl_LocalInvocationID.x)/gl_WorkGroupSize.x;
			if(outCol.r > 1)
			{
				outCol.r = 1;
			}
			if(outCol.g > 1)
			{
				outCol.g = 1;
			}
			if(outCol.b > 1)
			{
				outCol.b = 1;
			}
			outCol.a = gl_WorkGroupID.x;
			imageStore(lightMapOut, ivec2(floor(coord)), outCol);
			coord += xyDelta;
		}
	}
	return;
}